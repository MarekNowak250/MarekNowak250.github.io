{"title":"Uproszczenie wdra\u017Cania wzorca MVVM z pomoc\u0105 MVVM Toolkit","date":"30/07/2023 04:32","lastEditDate":"30/07/2023 05:52","content":[{"props":[],"content":"Ciemne strony pracy z MVVM","name":"header"},{"props":[],"content":"Wdra\u017Canie wzorca MVVM potrafi by\u0107 niezmiernie upierdliwe, a ilo\u015B\u0107 powtarzalnego kodu ro\u015Bnie w zastraszaj\u0105cym tempie. Jako, \u017Ce jest to popularnie stosowany wzorzec z rozwi\u0105zaniem tego problemu wysz\u0142a spo\u0142eczno\u015B\u0107 .NET tworz\u0105c bibliotek\u0119 MVVM Toolkit upraszczaj\u0105c\u0105 i przy\u015Bpieszaj\u0105c\u0105 wdra\u017Canie modelu.","name":"paragraph"},{"props":[],"content":"Kr\u00F3tkie przedstawienie MVVM","name":"header"},{"props":[],"content":"Model-View-ViewModel to wzorzec architektoniczny wspierany w frameworkach opracowanych przez Microsoft m.in. WPF, Xamarin. Za zadanie ma oddzieli\u0107 GUI od logiki biznesowej, pozwalaj\u0105c na niezale\u017Cn\u0105 prac\u0119 nad obiema warstwami.","name":"paragraph"},{"props":[],"content":"Model","name":"header"},{"props":[],"content":"Klasy modelu reprezentuj\u0105 dane i logik\u0119 biznesow\u0105, s\u0105 swoistym no\u015Bnikiem danych.","name":"paragraph"},{"props":[],"content":"View","name":"header"},{"props":[],"content":"View czyli widok to warstwa odpowiedzialna za komunikacj\u0119 z u\u017Cytkownikiem w WPF jest to kod XAML tworz\u0105cy interfejs u\u017Cytkownika (okna, kontrolki).","name":"paragraph"},{"props":[],"content":"Z widokiem modelu porozumiewa si\u0119 poprzez wi\u0105zanie \u2013 mechanizm pozwalaj\u0105cy na automatyczn\u0105 aktualizacj\u0119 widoku (oraz poinformowanie modelu widoku o np. naci\u015Bni\u0119ciu przycisku).","name":"paragraph"},{"props":[],"content":"ViewModel","name":"header"},{"props":[],"content":"ViewModel to warstwa po\u015Brednia, kt\u00F3ra stanowi kontekst danych dla widoku.","name":"paragraph"},{"props":[],"content":"osiada w sobie referencje do obiekt\u00F3w modelu, kt\u00F3rego dane przetwarza i udost\u0119pnia jako w\u0142a\u015Bciwo\u015Bci do \u201Ewi\u0105zania\u201D.","name":"paragraph"},{"props":[],"content":"Posiada tak\u017Ce obs\u0142ug\u0119 reakcji na dzia\u0142ania zachodz\u0105ce w widoku (np. na klikni\u0119cie przycisku).","name":"paragraph"},{"props":[],"content":"W celu poprawnej obs\u0142ugi wi\u0105zania musi implementowa\u0107 interfejs IPropertyChanged.","name":"paragraph"},{"props":[],"content":"Co wa\u017Cne warstwa ta jest ca\u0142kowicie niezale\u017Cna od widoku \u2013 nie powinna nic o nim \u201Ewiedzie\u0107\u201D i dzia\u0142a\u0107 ca\u0142kowicie autonomicznie (np. usuni\u0119cie widok\u00F3w nie powinno w \u017Caden spos\u00F3b wp\u0142yn\u0105\u0107 na ViewModel).","name":"paragraph"},{"props":[],"content":"Czym jest MVVM Toolkit","name":"header"},{"props":[],"content":"MVVM Toolkit to modu\u0142owa biblioteka MVVM, mo\u017Cliwa do wykorzystanie w ka\u017Cdej aplikacji .NET, kt\u00F3ra jest kompatybilna z .NET Standard 2.x.","name":"paragraph"},{"props":[],"content":"Udost\u0119pnia ona liczne modu\u0142y u\u0142atwiaj\u0105ce implementacj\u0119 wzorca, a tak\u017Ce dodaje nowe gotowe komponenty do wykorzystania, np. konwertery.","name":"paragraph"},{"props":[],"content":"Biblioteka posiada do\u015B\u0107 czyteln\u0105 i intuicyjn\u0105 dokumentacj\u0119 znajduj\u0105c\u0105 si\u0119 tutaj: https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/ oraz udost\u0119pnia do wgl\u0105du (i modyfikacji) kod \u017Ar\u00F3d\u0142owy (https://github.com/CommunityToolkit/dotnet).","name":"paragraph"},{"props":[],"content":"Podstawowe bindowanie","name":"header"},{"props":[],"content":"Domy\u015Blnie w celu udost\u0119pnienia w\u0142a\u015Bciwo\u015Bci do bindowania wymagana jest implementacja interfejsu INotifyPropertyChanged jak na listingu 1 lub jak na listingu 2","name":"paragraph"},{"props":[{"name":"lang","content":"csharp"}],"content":" public event PropertyChangedEventHandler? PropertyChanged;\r\n\r\n    protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)\r\n    {\r\n        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\r\n    }\r\n\r\n    public string Username \r\n    {  \r\n        get  \r\n        {  \r\n            return username;  \r\n        }  \r\n        set  \r\n        {  \r\n            username = value;  \r\n            OnPropertyChanged(\u0022Username\u0022);  \r\n        }  \r\n    }","name":"code"},{"props":[{"name":"lang","content":"csharp"}],"content":" protected bool SetProperty\u003CT\u003E(ref T field, T value, [CallerMemberName] string? propertyName = null)\r\n    {\r\n        if (EqualityComparer\u003CT\u003E.Default.Equals(field, value)) return false;\r\n        field = value;\r\n        OnPropertyChanged(propertyName);\r\n        return true;\r\n    }\r\n\r\n    private string username;\r\n\r\n    public string Username\r\n    {\r\n        get =\u003E username;\r\n        set =\u003E SetProperty(ref username, value);\r\n    }","name":"code"},{"props":[],"content":"Omawiana biblioteka udost\u0119pnia mo\u017Cliwo\u015B\u0107 znacznego uproszczenia i skr\u00F3cenia tego kodu. W tym celu wystarczy oznaczy\u0107 pole atrybutem ObservableProperty. Dodatkowo pole musi znajdowa\u0107 si\u0119 w klasie \u0022partial\u0022, kt\u00F3ra dziedziczy po ObservableObject.","name":"paragraph"},{"props":[{"name":"lang","content":"csharp"}],"content":"public partial class LoginViewModel : ObservableObject\r\n{\r\n    [ObservableProperty] private string username;\r\n}","name":"code"},{"props":[],"content":"Po oznaczeniu pola biblioteka przekszta\u0142ci kod w spos\u00F3b umo\u017Cliwiaj\u0105cy bindowanie (listing 4).","name":"paragraph"},{"props":[{"name":"lang","content":"csharp"}],"content":"    public string Username\r\n    {\r\n        get =\u003E username;\r\n        set =\u003E SetProperty(ref username, value);\r\n    }","name":"code"},{"props":[],"content":"Komendy","name":"header"},{"props":[],"content":"Biblioteka ta udost\u0119pnia r\u00F3wnie\u017C atrybut [RelayCommand] pozwalaj\u0105cy na oznaczanie funkcji, kt\u00F3re nast\u0119pnie mog\u0105 by\u0107 bindowane przez widok (np. w Command kontrolki Button).","name":"paragraph"},{"props":[],"content":"Normalnie nale\u017Ca\u0142oby stworzy\u0107 klas\u0119 implementuj\u0105c\u0105 interfejs ICommand (listing 5), a nast\u0119pnie tworzy\u0107 obiekty tej klasy (listing 6). Czyli nale\u017Ca\u0142oby tworzy\u0107 now\u0105 klas\u0119 dla ka\u017Cdego polecenia, koszmar czy\u017C nie?","name":"paragraph"},{"props":[{"name":"lang","content":"csharp"}],"content":"public class LoginCommand: ICommand\r\n{\r\n    private readonly LoginViewModelFrameworkless context;\r\n\r\n    public LoginCommand(LoginViewModelFrameworkless context)\r\n    {\r\n        this.context = context;\r\n    }\r\n\r\n    public bool CanExecute(object? parameter)\r\n    {\r\n        if (string.IsNullOrEmpty(context.Username) \r\n                              || string.IsNullOrEmpty(context.Password))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    public void Execute(object? parameter)\r\n    {\r\n        //obs\u0142uga logowania\r\n        MessageBox.Show($\u0022Loguj\u0119: {context.Username}\u0022, \u0022Logowanie\u0022);\r\n    }\r\n\r\n    public event EventHandler? CanExecuteChanged\r\n    {\r\n        add\r\n        {\r\n            CommandManager.RequerySuggested \u002B= value;\r\n        }\r\n        remove\r\n        {\r\n            CommandManager.RequerySuggested -= value;\r\n        }\r\n    }\r\n}","name":"code"},{"props":[{"name":"lang","content":"csharp"}],"content":"   public ICommand LoginCommand\r\n    {\r\n        get\r\n        {\r\n            if (loginCommand is null)\r\n                loginCommand = new LoginCommand(this);\r\n            return loginCommand;\r\n        }\r\n    }","name":"code"},{"props":[],"content":"Jednak szybko do powszechnego u\u017Cytku og\u00F3lna klasa RelayCommand (przyk\u0142adowa implementacja opisana zosta\u0142a np. tutaj - https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/february/patterns-wpf-apps-with-the-model-view-viewmodel-design-pattern, ukazana zosta\u0142a tak\u017Ce na listingu 7).","name":"paragraph"},{"props":[],"content":"W tym przypadku wystarczy stworzy\u0107 jej obiekt podaj\u0105c jako argumenty odwo\u0142anie do metod (listing 8).","name":"paragraph"},{"props":[{"name":"lang","content":"csharp"}],"content":"public class RelayCommand : ICommand    \r\n{    \r\n    private Action\u003Cobject\u003E execute;    \r\n    private Func\u003Cobject, bool\u003E canExecute;    \r\n     \r\n    public event EventHandler CanExecuteChanged    \r\n    {    \r\n        add { CommandManager.RequerySuggested \u002B= value; }    \r\n        remove { CommandManager.RequerySuggested -= value; }    \r\n    }    \r\n     \r\n    public RelayCommand(Action\u003Cobject\u003E execute, Func\u003Cobject, bool\u003E canExecute = null)    \r\n    {    \r\n        this.execute = execute;    \r\n        this.canExecute = canExecute;    \r\n    }    \r\n     \r\n    public bool CanExecute(object parameter)    \r\n    {    \r\n        return this.canExecute == null || this.canExecute(parameter);    \r\n    }    \r\n     \r\n    public void Execute(object parameter)    \r\n    {    \r\n        this.execute(parameter);    \r\n    }    \r\n}  ","name":"code"},{"props":[{"name":"lang","content":"csharp"}],"content":"    private ICommand loginCommand;\r\n\r\n    public ICommand LoginCommand\r\n    {\r\n        get\r\n        {\r\n            if (loginCommand is null)\r\n                loginCommand = new RelayCommand(\r\n                    arg =\u003E\r\n                    {\r\n                        //Obs\u0142uga logowania\r\n                        MessageBox.Show($\u0022Loguj\u0119: {Username}\u0022, \u0022Logowanie\u0022);\r\n                    });\r\n            return loginCommand;\r\n        }\r\n    }","name":"code"},{"props":[],"content":"Dzi\u0119ki atrybutowi (listing 9) pozbywamy si\u0119 tej \u017Cmudnej pracy, biblioteka znowu sama odpowiednio przetworzy kod.","name":"paragraph"},{"props":[{"name":"lang","content":"csharp"}],"content":"    [RelayCommand]\r\n    private void Login()\r\n    {\r\n        //Obs\u0142uga logowania\r\n        MessageBox.Show($\u0022Loguj\u0119: {Username}\u0022, \u0022Logowanie\u0022);\r\n    }","name":"code"},{"props":[],"content":"Wi\u0105zanie nale\u017Cy wykona\u0107 do wygenerowanego obiektu klasy RelayCommand - trzeba poda\u0107 nazw\u0119: [nazwa_metody_opatrzonej_atrybutem]Command, w tym przypadku LoginCommand.","name":"info"},{"props":[],"content":"Od\u015Bwie\u017Canie innych w\u0142a\u015Bciwo\u015Bci","name":"header"},{"props":[],"content":"W celu od\u015Bwie\u017Cenia innych w\u0142a\u015Bciwo\u015Bci (czyli wywo\u0142anie ich OnPropertyChanged, \u017Ceby powiadomi\u0107 widok) wystarczy doda\u0107 atrybut NotifyPropertyChangedFor jak na listingu 10. Zostanie to przetworzone do postaci kodu ukazanego na listingu 11.","name":"paragraph"},{"props":[{"name":"lang","content":"csharp"}],"content":"    [ObservableProperty]\r\n    [NotifyPropertyChangedFor(nameof(UsernamePassword))]\r\n    private string username;\r\n\r\n    public string UsernamePassword =\u003E $\u0022{username} {password}\u0022;","name":"code"},{"props":[{"name":"lang","content":"csharp"}],"content":"    public string Username \r\n    {  \r\n        get  \r\n        {  \r\n            return username;  \r\n        }  \r\n        set  \r\n        {  \r\n            username = value;  \r\n            OnPropertyChanged(\u0022Username\u0022);\r\n            OnPropertyChanged(\u0022UsernamePassword\u0022);\r\n        }  \r\n    }","name":"code"},{"props":[],"content":"Stan przycisk\u00F3w (enabled/disabled)","name":"header"},{"props":[],"content":"\u017Beby zadba\u0107 o odpowiedni stan przycisk\u00F3w (automatyczne w\u0142\u0105czanie/wy\u0142\u0105czanie) nale\u017Cy zdefiniowa\u0107 odpowiedni\u0105 metod\u0119 zwracaj\u0105c\u0105 bool, a nast\u0119pnie przypisa\u0107 j\u0105 do CanExecute obiektu klasy implementuj\u0105cej interfejs ICommand, np. tak to wygl\u0105da w przypadku RelayCommand:","name":"paragraph"},{"props":[{"name":"lang","content":"csharp"}],"content":"    public ICommand LoginCommand\r\n    {\r\n        get\r\n        {\r\n            if (loginCommand is null)\r\n                loginCommand = new RelayCommand(\r\n                    arg =\u003E\r\n                    {\r\n                        //Obs\u0142uga logowania\r\n                        MessageBox.Show($\u0022Loguj\u0119: {Username}\u0022, \u0022Logowanie\u0022);\r\n                    },\r\n                    arg =\u003E\r\n                    {\r\n                        if (string.IsNullOrEmpty(Username)\r\n                            || string.IsNullOrEmpty(Password))\r\n                            return false;\r\n                        return true;\r\n                    });\r\n            return loginCommand;\r\n        }","name":"code"},{"props":[],"content":"U\u017Cywaj\u0105c MVVM Community Toolkit w tym celu przypisujemy nazw\u0119 funkcji do argumentu CanExecute atrybutu RelayCommand, jak poni\u017Cej:","name":"paragraph"},{"props":[{"name":"lang","content":"csharp"}],"content":"    [RelayCommand(CanExecute = nameof(CanLogin))]\r\n    private void Login()\r\n    {\r\n        //Obs\u0142uga logowania\r\n        MessageBox.Show($\u0022Loguj\u0119: {Username}\u0022, \u0022Logowanie\u0022);\r\n    }\r\n\r\n    private bool CanLogin()\r\n    {\r\n        if (string.IsNullOrEmpty(Username) \r\n            || string.IsNullOrEmpty(Password))\r\n            return false;\r\n        return true;\r\n    }","name":"code"},{"props":[],"content":"Tym razem jednak musimy tak\u017Ce doda\u0107 atrybut NotifyCanExecuteChangedFor do p\u00F3l, kt\u00F3rych zmiana ma wywo\u0142ywa\u0107 metod\u0119 przypisan\u0105 do CanExecute (listing 14). W przypadku RelayCommand stan jest od\u015Bwie\u017Cany automatycznie z pomoc\u0105 kodu z listingu 15.","name":"paragraph"},{"props":[{"name":"lang","content":"csharp"}],"content":"    [ObservableProperty]\r\n    [NotifyCanExecuteChangedFor(nameof(LoginCommand))]\r\n    private string username;","name":"code"},{"props":[{"name":"lang","content":"csharp"}],"content":"    public event EventHandler CanExecuteChanged    \r\n    {    \r\n        add { CommandManager.RequerySuggested \u002B= value; }    \r\n        remove { CommandManager.RequerySuggested -= value; }    \r\n    }    ","name":"code"},{"props":[],"content":"Kod \u017Ar\u00F3d\u0142owy","name":"header"},{"props":[],"content":"Kod \u017Ar\u00F3d\u0142owy aplikacji zawieraj\u0105cej wszystkie om\u00F3wione tutaj mechanizmy mo\u017Cna podejrze\u0107 na: https://github.com/Krzaku250/Simplify-MVVM-Example_App/tree/main.","name":"paragraph"},{"props":[{"name":"alt","content":"Widok przyk\u0142adowej aplikacji"}],"content":"przykladowa_aplikacja.png","name":"img"},{"props":[],"content":"Aplikacja zawiera dwa widoki modelu: LoginViewModel oraz LoginViewModelFrameworkless.\r\n","name":"paragraph"},{"props":[],"content":"\u017Beby przetestowa\u0107 ka\u017Cdy z nich osobno wystarczy podmieni\u0107 nazw\u0119 klasy na wybran\u0105 w MainWindow.xaml w Window.DataContext.","name":"paragraph"}]}